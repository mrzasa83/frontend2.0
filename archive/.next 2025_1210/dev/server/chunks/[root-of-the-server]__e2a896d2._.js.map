{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"sources":["file:///users/mrzasa/projects/current/frontend2.4/app/api/products/bom/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\r\nimport sql from 'mssql'\r\n\r\n// Production Database Connection (SQL Server)\r\nconst config = {\r\n  server: process.env.PRODUCTION_DB_HOST || '',\r\n  database: process.env.PRODUCTION_DB_NAME || '',\r\n  user: process.env.PRODUCTION_DB_USER || '',\r\n  password: process.env.PRODUCTION_DB_PASSWORD || '',\r\n  options: {\r\n    encrypt: true, // Use encryption\r\n    trustServerCertificate: true // For local dev\r\n  }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const { apcPN, level = 0, isInventoryPart = false } = await request.json()\r\n\r\n    if (!apcPN) {\r\n      return NextResponse.json(\r\n        { error: 'apcPN is required' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    // Connect to SQL Server\r\n    const pool = await sql.connect(config)\r\n\r\n    let result: any\r\n\r\n    // Two different queries depending on if this is a customer part or inventory part\r\n    if (isInventoryPart) {\r\n      // For inventory parts (manufactured parts from data0017)\r\n      result = await pool.request()\r\n        .input('apcPN', sql.VarChar, apcPN)\r\n        .query(`\r\n          SELECT \r\n            d17.INV_PART_NUMBER AS parent_part,\r\n            d17.P_M AS parent_type,\r\n            d25.RKEY AS bom_header_key,\r\n            d25.EFF_END AS eff_end,\r\n            d26.QTY_BOM AS quantity,\r\n            d26.UNIT_PTR AS unit_ptr,\r\n            d26.REFERENCE_DESIGNATORS AS ref_des,\r\n            d26.SEQUENCE AS sequence,\r\n            d17_1.INV_PART_NUMBER AS component_part,\r\n            d17_1.DESCRIPTION AS description,\r\n            d17_1.P_M AS component_type,\r\n            d17_1.RKEY AS component_rkey,\r\n            CASE WHEN d17_1.P_M = 'M' THEN 1 ELSE 0 END AS has_children\r\n          FROM data0017 d17\r\n          JOIN data0025 d25 ON d17.RKEY = d25.INVENTORY_PTR\r\n          JOIN data0026 d26 ON d25.RKEY = d26.PARENT_NODE_INVENT\r\n          JOIN data0017 d17_1 ON d17_1.RKEY = d26.INVENTORY_PTR\r\n          WHERE d17.INV_PART_NUMBER = @apcPN\r\n            AND d17.P_M = 'M'\r\n            AND (d25.EFF_END IS NULL OR d25.EFF_END > GETDATE())\r\n          ORDER BY d26.SEQUENCE, d17_1.INV_PART_NUMBER\r\n        `)\r\n    } else {\r\n      // For customer parts (from data0050)\r\n      result = await pool.request()\r\n        .input('apcPN', sql.VarChar, `${apcPN}%`)\r\n        .query(`\r\n          SELECT \r\n            d50.CUSTOMER_PART_NUMBER AS parent_part,\r\n            'C' AS parent_type,\r\n            d25.RKEY AS bom_header_key,\r\n            d25.EFF_END AS eff_end,\r\n            d26.QTY_BOM AS quantity,\r\n            d26.UNIT_PTR AS unit_ptr,\r\n            d26.REFERENCE_DESIGNATORS AS ref_des,\r\n            d26.SEQUENCE AS sequence,\r\n            d17.INV_PART_NUMBER AS component_part,\r\n            d17.DESCRIPTION AS description,\r\n            d17.P_M AS component_type,\r\n            d17.RKEY AS component_rkey,\r\n            CASE WHEN d17.P_M = 'M' THEN 1 ELSE 0 END AS has_children\r\n          FROM data0050 d50\r\n          JOIN data0025 d25 ON d50.BOM_PTR = d25.RKEY\r\n          JOIN data0026 d26 ON d25.RKEY = d26.PARENT_NODE_INVENT\r\n          JOIN data0017 d17 ON d26.INVENTORY_PTR = d17.RKEY\r\n          WHERE d50.CUSTOMER_PART_NUMBER LIKE @apcPN\r\n            AND (d25.EFF_END IS NULL OR d25.EFF_END > GETDATE())\r\n          ORDER BY d26.SEQUENCE, d17.INV_PART_NUMBER\r\n        `)\r\n    }\r\n\r\n    const rows = result.recordset\r\n\r\n    console.log(`BOM Query for ${apcPN} (${isInventoryPart ? 'Inventory' : 'Customer'} part): Found ${rows.length} components`)\r\n\r\n    // Transform results to match BOMItem type\r\n    const results = rows.map((row: any, index: number) => ({\r\n      id: `${row.component_part}-${level}-${index}`,\r\n      part_number: row.component_part,\r\n      description: row.description || '',\r\n      quantity: parseFloat(row.quantity) || 0,\r\n      ref_des: row.ref_des || '',\r\n      unit: row.unit_ptr || '',\r\n      level: level,\r\n      has_children: Boolean(row.has_children),\r\n      parent_part: row.parent_part,\r\n      component_type: row.component_type,\r\n      sequence: row.sequence,\r\n      eff_end: row.eff_end\r\n    }))\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      results,\r\n      count: results.length,\r\n      debug: {\r\n        partNumber: apcPN,\r\n        isInventoryPart,\r\n        level\r\n      }\r\n    })\r\n  } catch (error) {\r\n    console.error('Error fetching BOM data:', error)\r\n    return NextResponse.json(\r\n      { \r\n        error: 'Failed to fetch BOM data',\r\n        details: error instanceof Error ? error.message : 'Unknown error'\r\n      },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\n/* ============================================\r\n   SCHEMA UNDERSTANDING\r\n   ============================================\r\n   \r\n   TWO TYPES OF PARTS:\r\n   \r\n   1. CUSTOMER PARTS (data0050)\r\n      - CUSTOMER_PART_NUMBER (unique ID)\r\n      - BOM_PTR → points to data0025.RKEY\r\n      - These are assemblies for customers\r\n   \r\n   2. INVENTORY PARTS (data0017)\r\n      - INV_PART_NUMBER (unique ID)\r\n      - P_M flag: 'P' = Purchased, 'M' = Manufactured\r\n      - RKEY (primary key)\r\n      - If P_M = 'M', part has a BOM\r\n   \r\n   BOM STRUCTURE:\r\n   \r\n   data0025 - BOM Headers\r\n     - RKEY (primary key)\r\n     - INVENTORY_PTR → points to data0017.RKEY (for manufactured parts)\r\n     - EFF_END (effectivity date)\r\n   \r\n   data0026 - BOM Line Items (components)\r\n     - PARENT_NODE_INVENT → points to data0025.RKEY\r\n     - INVENTORY_PTR → points to data0017.RKEY (the component)\r\n     - QTY_BOM (quantity needed)\r\n     - REFERENCE_DESIGNATORS\r\n     - SEQUENCE (sort order)\r\n   \r\n   RELATIONSHIPS:\r\n   \r\n   Customer Part BOM:\r\n   data0050 → (BOM_PTR) → data0025 → (PARENT_NODE_INVENT) → data0026 → (INVENTORY_PTR) → data0017\r\n   \r\n   Manufactured Part BOM:\r\n   data0017 → (INVENTORY_PTR) → data0025 → (PARENT_NODE_INVENT) → data0026 → (INVENTORY_PTR) → data0017\r\n   \r\n   ============================================\r\n   TREE NAVIGATION LOGIC\r\n   ============================================\r\n   \r\n   1. Start with customer part (e.g., \"12034 REV A\")\r\n   2. Query returns components from data0017\r\n   3. For each component, check P_M:\r\n      - If P_M = 'P': Purchased part (leaf node, no children)\r\n      - If P_M = 'M': Manufactured part (has_children = true)\r\n   4. When user expands a manufactured component:\r\n      - Call API again with INV_PART_NUMBER\r\n      - Set isInventoryPart = true\r\n      - Uses second query to find its BOM\r\n   5. Repeat recursively for nested assemblies\r\n   \r\n   ============================================ */"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,8CAA8C;AAC9C,MAAM,SAAS;IACb,QAAQ,QAAQ,GAAG,CAAC,kBAAkB,IAAI;IAC1C,UAAU,QAAQ,GAAG,CAAC,kBAAkB,IAAI;IAC5C,MAAM,QAAQ,GAAG,CAAC,kBAAkB,IAAI;IACxC,UAAU,QAAQ,GAAG,CAAC,sBAAsB,IAAI;IAChD,SAAS;QACP,SAAS;QACT,wBAAwB,KAAK,gBAAgB;IAC/C;AACF;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC,EAAE,kBAAkB,KAAK,EAAE,GAAG,MAAM,QAAQ,IAAI;QAExE,IAAI,CAAC,OAAO;YACV,OAAO,kKAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAoB,GAC7B;gBAAE,QAAQ;YAAI;QAElB;QAEA,wBAAwB;QACxB,MAAM,OAAO,MAAM,6JAAG,CAAC,OAAO,CAAC;QAE/B,IAAI;QAEJ,kFAAkF;QAClF,IAAI,iBAAiB;YACnB,yDAAyD;YACzD,SAAS,MAAM,KAAK,OAAO,GACxB,KAAK,CAAC,SAAS,6JAAG,CAAC,OAAO,EAAE,OAC5B,KAAK,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;QAuBR,CAAC;QACL,OAAO;YACL,qCAAqC;YACrC,SAAS,MAAM,KAAK,OAAO,GACxB,KAAK,CAAC,SAAS,6JAAG,CAAC,OAAO,EAAE,GAAG,MAAM,CAAC,CAAC,EACvC,KAAK,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;QAsBR,CAAC;QACL;QAEA,MAAM,OAAO,OAAO,SAAS;QAE7B,QAAQ,GAAG,CAAC,CAAC,cAAc,EAAE,MAAM,EAAE,EAAE,kBAAkB,cAAc,WAAW,cAAc,EAAE,KAAK,MAAM,CAAC,WAAW,CAAC;QAE1H,0CAA0C;QAC1C,MAAM,UAAU,KAAK,GAAG,CAAC,CAAC,KAAU,QAAkB,CAAC;gBACrD,IAAI,GAAG,IAAI,cAAc,CAAC,CAAC,EAAE,MAAM,CAAC,EAAE,OAAO;gBAC7C,aAAa,IAAI,cAAc;gBAC/B,aAAa,IAAI,WAAW,IAAI;gBAChC,UAAU,WAAW,IAAI,QAAQ,KAAK;gBACtC,SAAS,IAAI,OAAO,IAAI;gBACxB,MAAM,IAAI,QAAQ,IAAI;gBACtB,OAAO;gBACP,cAAc,QAAQ,IAAI,YAAY;gBACtC,aAAa,IAAI,WAAW;gBAC5B,gBAAgB,IAAI,cAAc;gBAClC,UAAU,IAAI,QAAQ;gBACtB,SAAS,IAAI,OAAO;YACtB,CAAC;QAED,OAAO,kKAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA,OAAO,QAAQ,MAAM;YACrB,OAAO;gBACL,YAAY;gBACZ;gBACA;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,kKAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD,GACA;YAAE,QAAQ;QAAI;IAElB;AACF,EAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gDAsDgD","debugId":null}}]
}