{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 142, "column": 0}, "map": {"version":3,"sources":["file:///users/mrzasa/projects/current/frontend2.4/lib/db/mysql-primary.ts"],"sourcesContent":["import mysql from 'mysql2/promise'\r\n\r\nlet pool: mysql.Pool | null = null\r\n\r\nexport function getMySQLPrimaryPool() {\r\n  if (!pool) {\r\n    pool = mysql.createPool({\r\n      host: process.env.DB_MYSQL_PRIMARY_HOST,\r\n      port: parseInt(process.env.DB_MYSQL_PRIMARY_PORT || '3306'),\r\n      user: process.env.DB_MYSQL_PRIMARY_USER,\r\n      password: process.env.DB_MYSQL_PRIMARY_PASSWORD,\r\n      database: process.env.DB_MYSQL_PRIMARY_DATABASE,\r\n      waitForConnections: true,\r\n      connectionLimit: 10,\r\n      queueLimit: 0,\r\n      enableKeepAlive: true,\r\n      keepAliveInitialDelay: 0\r\n    })\r\n  }\r\n  return pool\r\n}\r\n\r\nexport async function queryPrimary<T = any>(\r\n  sql: string,\r\n  params?: any[]\r\n): Promise<T> {\r\n  const pool = getMySQLPrimaryPool()\r\n  const [rows] = await pool.execute(sql, params)\r\n  return rows as T\r\n}\r\n\r\n// Test connection\r\nexport async function testMySQLPrimaryConnection() {\r\n  try {\r\n    const pool = getMySQLPrimaryPool()\r\n    const connection = await pool.getConnection()\r\n    await connection.ping()\r\n    connection.release()\r\n    return { success: true, message: 'MySQL Primary connected' }\r\n  } catch (error) {\r\n    return { success: false, message: `MySQL Primary error: ${error}` }\r\n  }\r\n}\r\n\r\n// At the end of mysql-primary.ts\r\nexport async function getUsers() {\r\n  return queryPrimary<any[]>(\r\n    `SELECT \r\n      id,\r\n      username,\r\n      name,\r\n      email,\r\n      nickname,\r\n      phone,\r\n      mobile,\r\n      title,\r\n      role,\r\n      active\r\n    FROM Users \r\n    WHERE active = 1\r\n    ORDER BY name ASC`\r\n  )\r\n}"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA,IAAI,OAA0B;AAEvB,SAAS;IACd,IAAI,CAAC,MAAM;QACT,OAAO,8IAAK,CAAC,UAAU,CAAC;YACtB,MAAM,QAAQ,GAAG,CAAC,qBAAqB;YACvC,MAAM,SAAS,QAAQ,GAAG,CAAC,qBAAqB,IAAI;YACpD,MAAM,QAAQ,GAAG,CAAC,qBAAqB;YACvC,UAAU,QAAQ,GAAG,CAAC,yBAAyB;YAC/C,UAAU,QAAQ,GAAG,CAAC,yBAAyB;YAC/C,oBAAoB;YACpB,iBAAiB;YACjB,YAAY;YACZ,iBAAiB;YACjB,uBAAuB;QACzB;IACF;IACA,OAAO;AACT;AAEO,eAAe,aACpB,GAAW,EACX,MAAc;IAEd,MAAM,OAAO;IACb,MAAM,CAAC,KAAK,GAAG,MAAM,KAAK,OAAO,CAAC,KAAK;IACvC,OAAO;AACT;AAGO,eAAe;IACpB,IAAI;QACF,MAAM,OAAO;QACb,MAAM,aAAa,MAAM,KAAK,aAAa;QAC3C,MAAM,WAAW,IAAI;QACrB,WAAW,OAAO;QAClB,OAAO;YAAE,SAAS;YAAM,SAAS;QAA0B;IAC7D,EAAE,OAAO,OAAO;QACd,OAAO;YAAE,SAAS;YAAO,SAAS,CAAC,qBAAqB,EAAE,OAAO;QAAC;IACpE;AACF;AAGO,eAAe;IACpB,OAAO,aACL,CAAC;;;;;;;;;;;;;qBAagB,CAAC;AAEtB","debugId":null}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///users/mrzasa/projects/current/frontend2.4/lib/auth.ts"],"sourcesContent":["import { NextAuthOptions } from 'next-auth'\r\nimport CredentialsProvider from 'next-auth/providers/credentials'\r\nimport bcrypt from 'bcryptjs'\r\nimport { queryPrimary } from './db/mysql-primary'\r\n\r\ninterface User {\r\n  id: number\r\n  username: string\r\n  name: string | null\r\n  email: string | null\r\n  password: string\r\n  active: number | null\r\n}\r\n\r\ninterface Role {\r\n  id: number\r\n  name: string\r\n}\r\n\r\nexport const authOptions: NextAuthOptions = {\r\n  providers: [\r\n    CredentialsProvider({\r\n      name: 'Credentials',\r\n      credentials: {\r\n        username: { label: 'Username', type: 'text' },\r\n        password: { label: 'Password', type: 'password' }\r\n      },\r\n      async authorize(credentials) {\r\n        if (!credentials?.username || !credentials?.password) {\r\n          return null\r\n        }\r\n\r\n        try {\r\n          // Get user\r\n          const users = await queryPrimary<User[]>(\r\n            'SELECT * FROM Users WHERE username = ? AND active = 1',\r\n            [credentials.username]\r\n          )\r\n\r\n          const user = users[0]\r\n\r\n          if (!user || !user.password) {\r\n            return null\r\n          }\r\n\r\n          // Verify password\r\n          const isValid = await bcrypt.compare(credentials.password, user.password)\r\n\r\n          if (!isValid) {\r\n            return null\r\n          }\r\n\r\n          // Get user roles\r\n          const roles = await queryPrimary<Role[]>(\r\n            `SELECT r.id, r.name \r\n             FROM roles r\r\n             INNER JOIN user_roles ur ON r.id = ur.roleId\r\n             WHERE ur.userId = ?`,\r\n            [user.id]\r\n          )\r\n\r\n          const roleNames = roles.map(r => r.name)\r\n\r\n          return {\r\n            id: user.id.toString(),\r\n            name: user.name || user.username,\r\n            email: user.email || '',\r\n            username: user.username,\r\n            roles: roleNames\r\n          }\r\n        } catch (error) {\r\n          console.error('Auth error:', error)\r\n          return null\r\n        }\r\n      }\r\n    })\r\n  ],\r\n  callbacks: {\r\n    async jwt({ token, user }) {\r\n      if (user) {\r\n        token.id = user.id\r\n        token.username = user.username\r\n        token.roles = user.roles\r\n      }\r\n      return token\r\n    },\r\n    async session({ session, token }) {\r\n      if (session.user) {\r\n        session.user.id = token.id as string\r\n        session.user.username = token.username as string\r\n        session.user.roles = token.roles as string[]\r\n        \r\n        // Create initials from name\r\n        const nameParts = session.user.name?.split(' ') || ['U']\r\n        session.user.initials = nameParts.length > 1 \r\n          ? `${nameParts[0][0]}${nameParts[1][0]}`.toUpperCase()\r\n          : nameParts[0].substring(0, 2).toUpperCase()\r\n      }\r\n      return session\r\n    }\r\n  },\r\n  pages: {\r\n    signIn: '/login',\r\n  },\r\n  session: {\r\n    strategy: 'jwt',\r\n    maxAge: 30 * 24 * 60 * 60, // 30 days\r\n  },\r\n  secret: process.env.NEXTAUTH_SECRET,\r\n}"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAgBO,MAAM,cAA+B;IAC1C,WAAW;QACT,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAO;gBAC5C,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,YAAY,CAAC,aAAa,UAAU;oBACpD,OAAO;gBACT;gBAEA,IAAI;oBACF,WAAW;oBACX,MAAM,QAAQ,MAAM,IAAA,+IAAY,EAC9B,yDACA;wBAAC,YAAY,QAAQ;qBAAC;oBAGxB,MAAM,OAAO,KAAK,CAAC,EAAE;oBAErB,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;wBAC3B,OAAO;oBACT;oBAEA,kBAAkB;oBAClB,MAAM,UAAU,MAAM,8IAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ;oBAExE,IAAI,CAAC,SAAS;wBACZ,OAAO;oBACT;oBAEA,iBAAiB;oBACjB,MAAM,QAAQ,MAAM,IAAA,+IAAY,EAC9B,CAAC;;;gCAGmB,CAAC,EACrB;wBAAC,KAAK,EAAE;qBAAC;oBAGX,MAAM,YAAY,MAAM,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI;oBAEvC,OAAO;wBACL,IAAI,KAAK,EAAE,CAAC,QAAQ;wBACpB,MAAM,KAAK,IAAI,IAAI,KAAK,QAAQ;wBAChC,OAAO,KAAK,KAAK,IAAI;wBACrB,UAAU,KAAK,QAAQ;wBACvB,OAAO;oBACT;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,eAAe;oBAC7B,OAAO;gBACT;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,QAAQ,GAAG,KAAK,QAAQ;gBAC9B,MAAM,KAAK,GAAG,KAAK,KAAK;YAC1B;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,QAAQ,IAAI,CAAC,QAAQ,GAAG,MAAM,QAAQ;gBACtC,QAAQ,IAAI,CAAC,KAAK,GAAG,MAAM,KAAK;gBAEhC,4BAA4B;gBAC5B,MAAM,YAAY,QAAQ,IAAI,CAAC,IAAI,EAAE,MAAM,QAAQ;oBAAC;iBAAI;gBACxD,QAAQ,IAAI,CAAC,QAAQ,GAAG,UAAU,MAAM,GAAG,IACvC,GAAG,SAAS,CAAC,EAAE,CAAC,EAAE,GAAG,SAAS,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,WAAW,KAClD,SAAS,CAAC,EAAE,CAAC,SAAS,CAAC,GAAG,GAAG,WAAW;YAC9C;YACA,OAAO;QACT;IACF;IACA,OAAO;QACL,QAAQ;IACV;IACA,SAAS;QACP,UAAU;QACV,QAAQ,KAAK,KAAK,KAAK;IACzB;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC","debugId":null}},
    {"offset": {"line": 326, "column": 0}, "map": {"version":3,"sources":["file:///users/mrzasa/projects/current/frontend2.4/lib/types/items.ts"],"sourcesContent":["export type MajorItemType = 'part' | 'doc'\r\n\r\nexport type ItemTypeCode = 'PIE' | 'CON' | 'T_V' | 'CCA' | 'PCB'\r\n\r\nexport interface Item {\r\n  id?: number\r\n  apcPN: string\r\n  customer?: string | null\r\n  customerPN?: string | null\r\n  buildRev?: string | null\r\n  currentRev?: string | null\r\n  description?: string | null\r\n  fullPath?: string | null\r\n  createdAt?: string\r\n  m_item_type_id: number  // 1=part, 2=doc\r\n  item_type_id: number    // 1=PIE, 2=CON, 3=T_V, 4=CCA, 5=PCB\r\n}\r\n\r\nexport interface ScannedPart {\r\n  apcPN: string\r\n  folderName: string\r\n  fullPath: string\r\n  customer?: string\r\n  customerPN?: string\r\n  currentRev?: string\r\n  item_type_id: number\r\n  existsInDB: boolean\r\n}\r\n\r\n// Map first digit to item_type_id\r\nexport function getItemTypeFromPartNumber(partNumber: string): number {\r\n  const firstDigit = partNumber.charAt(0)\r\n  switch (firstDigit) {\r\n    case '0': return 3  // Test Vehicle\r\n    case '1': return 4  // Circuit Card Assembly\r\n    case '3': return 2  // Connector\r\n    case '7': return 5  // PCB\r\n    case '9': return 1  // Piece Part\r\n    default: return 1   // Default to Piece Part\r\n  }\r\n}\r\n\r\n// Parse folder name: \"12747 Harris 8026565-1\" or \"12710 BAE 1050468-0001 Rev E-A\"\r\nexport function parseFolderName(folderName: string): {\r\n  apcPN: string\r\n  customer?: string\r\n  customerPN?: string\r\n  currentRev?: string\r\n} {\r\n  // Extract part number (first 5 digits)\r\n  const apcPN = folderName.substring(0, 5)\r\n  \r\n  // Remove part number and trim\r\n  let remaining = folderName.substring(5).trim()\r\n  \r\n  if (!remaining) {\r\n    return { apcPN }\r\n  }\r\n  \r\n  // Look for Rev pattern\r\n  const revMatch = remaining.match(/\\bRev\\s+([A-Za-z0-9-]+)/i)\r\n  let currentRev: string | undefined\r\n  if (revMatch) {\r\n    currentRev = revMatch[1]\r\n    remaining = remaining.replace(revMatch[0], '').trim()\r\n  }\r\n  \r\n  // Parse remaining as customer and customer PN\r\n  // Simple heuristic: if there are 2+ words, first is customer, rest is customer PN\r\n  const parts = remaining.split(/\\s+/)\r\n  \r\n  if (parts.length === 0) {\r\n    return { apcPN, currentRev }\r\n  } else if (parts.length === 1) {\r\n    // Could be customer or customer PN - hard to tell\r\n    // If it looks like a part number (has digits/dashes), treat as customerPN\r\n    if (/[\\d-]/.test(parts[0])) {\r\n      return { apcPN, customerPN: parts[0], currentRev }\r\n    } else {\r\n      return { apcPN, customer: parts[0], currentRev }\r\n    }\r\n  } else {\r\n    // Multiple words: first word is customer, rest is customer PN\r\n    const customer = parts[0]\r\n    const customerPN = parts.slice(1).join(' ')\r\n    return { apcPN, customer, customerPN, currentRev }\r\n  }\r\n}"],"names":[],"mappings":";;;;;;AA8BO,SAAS,0BAA0B,UAAkB;IAC1D,MAAM,aAAa,WAAW,MAAM,CAAC;IACrC,OAAQ;QACN,KAAK;YAAK,OAAO,EAAG,eAAe;;QACnC,KAAK;YAAK,OAAO,EAAG,wBAAwB;;QAC5C,KAAK;YAAK,OAAO,EAAG,YAAY;;QAChC,KAAK;YAAK,OAAO,EAAG,MAAM;;QAC1B,KAAK;YAAK,OAAO,EAAG,aAAa;;QACjC;YAAS,OAAO,EAAI,wBAAwB;;IAC9C;AACF;AAGO,SAAS,gBAAgB,UAAkB;IAMhD,uCAAuC;IACvC,MAAM,QAAQ,WAAW,SAAS,CAAC,GAAG;IAEtC,8BAA8B;IAC9B,IAAI,YAAY,WAAW,SAAS,CAAC,GAAG,IAAI;IAE5C,IAAI,CAAC,WAAW;QACd,OAAO;YAAE;QAAM;IACjB;IAEA,uBAAuB;IACvB,MAAM,WAAW,UAAU,KAAK,CAAC;IACjC,IAAI;IACJ,IAAI,UAAU;QACZ,aAAa,QAAQ,CAAC,EAAE;QACxB,YAAY,UAAU,OAAO,CAAC,QAAQ,CAAC,EAAE,EAAE,IAAI,IAAI;IACrD;IAEA,8CAA8C;IAC9C,kFAAkF;IAClF,MAAM,QAAQ,UAAU,KAAK,CAAC;IAE9B,IAAI,MAAM,MAAM,KAAK,GAAG;QACtB,OAAO;YAAE;YAAO;QAAW;IAC7B,OAAO,IAAI,MAAM,MAAM,KAAK,GAAG;QAC7B,kDAAkD;QAClD,0EAA0E;QAC1E,IAAI,QAAQ,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG;YAC1B,OAAO;gBAAE;gBAAO,YAAY,KAAK,CAAC,EAAE;gBAAE;YAAW;QACnD,OAAO;YACL,OAAO;gBAAE;gBAAO,UAAU,KAAK,CAAC,EAAE;gBAAE;YAAW;QACjD;IACF,OAAO;QACL,8DAA8D;QAC9D,MAAM,WAAW,KAAK,CAAC,EAAE;QACzB,MAAM,aAAa,MAAM,KAAK,CAAC,GAAG,IAAI,CAAC;QACvC,OAAO;YAAE;YAAO;YAAU;YAAY;QAAW;IACnD;AACF","debugId":null}},
    {"offset": {"line": 412, "column": 0}, "map": {"version":3,"sources":["file:///users/mrzasa/projects/current/frontend2.4/lib/importers/part-scanner.ts"],"sourcesContent":["import fs from 'fs/promises'\r\nimport path from 'path'\r\nimport { ScannedPart, parseFolderName, getItemTypeFromPartNumber } from '@/lib/types/items'\r\n\r\nconst BASE_PATH = '/mnt/jdrive/APC EngJobs'\r\n\r\n// Check if folder name matches range pattern: #####-#####\r\nfunction isRangeFolder(name: string): boolean {\r\n  return /^\\d{5}-\\d{5}$/.test(name)\r\n}\r\n\r\n// Check if folder name is a part folder: ##### or ##### followed by space\r\nfunction isPartFolder(name: string): boolean {\r\n  return /^\\d{5}(\\s|$)/.test(name)\r\n}\r\n\r\n// Scan a single range folder for parts\r\nasync function scanRangeFolder(rangeFolderPath: string): Promise<ScannedPart[]> {\r\n  const parts: ScannedPart[] = []\r\n  \r\n  try {\r\n    const entries = await fs.readdir(rangeFolderPath, { withFileTypes: true })\r\n    \r\n    for (const entry of entries) {\r\n      if (entry.isDirectory() && isPartFolder(entry.name)) {\r\n        const parsed = parseFolderName(entry.name)\r\n        const fullPath = path.join(rangeFolderPath, entry.name)\r\n        \r\n        parts.push({\r\n          apcPN: parsed.apcPN,\r\n          folderName: entry.name,\r\n          fullPath,\r\n          customer: parsed.customer,\r\n          customerPN: parsed.customerPN,\r\n          currentRev: parsed.currentRev,\r\n          item_type_id: getItemTypeFromPartNumber(parsed.apcPN),\r\n          existsInDB: false  // Will be checked later\r\n        })\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error scanning range folder ${rangeFolderPath}:`, error)\r\n  }\r\n  \r\n  return parts\r\n}\r\n\r\n// Scan all range folders in base path\r\nexport async function scanAllParts(): Promise<ScannedPart[]> {\r\n  const allParts: ScannedPart[] = []\r\n  \r\n  try {\r\n    const entries = await fs.readdir(BASE_PATH, { withFileTypes: true })\r\n    \r\n    for (const entry of entries) {\r\n      if (entry.isDirectory() && isRangeFolder(entry.name)) {\r\n        const rangePath = path.join(BASE_PATH, entry.name)\r\n        const parts = await scanRangeFolder(rangePath)\r\n        allParts.push(...parts)\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error scanning base path ${BASE_PATH}:`, error)\r\n    throw error\r\n  }\r\n  \r\n  return allParts\r\n}\r\n\r\n// Get list of range folders\r\nexport async function getRangeFolders(): Promise<string[]> {\r\n  try {\r\n    const entries = await fs.readdir(BASE_PATH, { withFileTypes: true })\r\n    return entries\r\n      .filter(entry => entry.isDirectory() && isRangeFolder(entry.name))\r\n      .map(entry => entry.name)\r\n      .sort()\r\n  } catch (error) {\r\n    console.error(`Error getting range folders:`, error)\r\n    return []\r\n  }\r\n}\r\n\r\n// Scan specific range folders\r\nexport async function scanSpecificRanges(ranges: string[]): Promise<ScannedPart[]> {\r\n  const allParts: ScannedPart[] = []\r\n  \r\n  for (const range of ranges) {\r\n    const rangePath = path.join(BASE_PATH, range)\r\n    const parts = await scanRangeFolder(rangePath)\r\n    allParts.push(...parts)\r\n  }\r\n  \r\n  return allParts\r\n}"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAEA,MAAM,YAAY;AAElB,0DAA0D;AAC1D,SAAS,cAAc,IAAY;IACjC,OAAO,gBAAgB,IAAI,CAAC;AAC9B;AAEA,0EAA0E;AAC1E,SAAS,aAAa,IAAY;IAChC,OAAO,eAAe,IAAI,CAAC;AAC7B;AAEA,uCAAuC;AACvC,eAAe,gBAAgB,eAAuB;IACpD,MAAM,QAAuB,EAAE;IAE/B,IAAI;QACF,MAAM,UAAU,MAAM,gIAAE,CAAC,OAAO,CAAC,iBAAiB;YAAE,eAAe;QAAK;QAExE,KAAK,MAAM,SAAS,QAAS;YAC3B,IAAI,MAAM,WAAW,MAAM,aAAa,MAAM,IAAI,GAAG;gBACnD,MAAM,SAAS,IAAA,0IAAe,EAAC,MAAM,IAAI;gBACzC,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,iBAAiB,MAAM,IAAI;gBAEtD,MAAM,IAAI,CAAC;oBACT,OAAO,OAAO,KAAK;oBACnB,YAAY,MAAM,IAAI;oBACtB;oBACA,UAAU,OAAO,QAAQ;oBACzB,YAAY,OAAO,UAAU;oBAC7B,YAAY,OAAO,UAAU;oBAC7B,cAAc,IAAA,oJAAyB,EAAC,OAAO,KAAK;oBACpD,YAAY,MAAO,wBAAwB;gBAC7C;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,4BAA4B,EAAE,gBAAgB,CAAC,CAAC,EAAE;IACnE;IAEA,OAAO;AACT;AAGO,eAAe;IACpB,MAAM,WAA0B,EAAE;IAElC,IAAI;QACF,MAAM,UAAU,MAAM,gIAAE,CAAC,OAAO,CAAC,WAAW;YAAE,eAAe;QAAK;QAElE,KAAK,MAAM,SAAS,QAAS;YAC3B,IAAI,MAAM,WAAW,MAAM,cAAc,MAAM,IAAI,GAAG;gBACpD,MAAM,YAAY,4GAAI,CAAC,IAAI,CAAC,WAAW,MAAM,IAAI;gBACjD,MAAM,QAAQ,MAAM,gBAAgB;gBACpC,SAAS,IAAI,IAAI;YACnB;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,yBAAyB,EAAE,UAAU,CAAC,CAAC,EAAE;QACxD,MAAM;IACR;IAEA,OAAO;AACT;AAGO,eAAe;IACpB,IAAI;QACF,MAAM,UAAU,MAAM,gIAAE,CAAC,OAAO,CAAC,WAAW;YAAE,eAAe;QAAK;QAClE,OAAO,QACJ,MAAM,CAAC,CAAA,QAAS,MAAM,WAAW,MAAM,cAAc,MAAM,IAAI,GAC/D,GAAG,CAAC,CAAA,QAAS,MAAM,IAAI,EACvB,IAAI;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,4BAA4B,CAAC,EAAE;QAC9C,OAAO,EAAE;IACX;AACF;AAGO,eAAe,mBAAmB,MAAgB;IACvD,MAAM,WAA0B,EAAE;IAElC,KAAK,MAAM,SAAS,OAAQ;QAC1B,MAAM,YAAY,4GAAI,CAAC,IAAI,CAAC,WAAW;QACvC,MAAM,QAAQ,MAAM,gBAAgB;QACpC,SAAS,IAAI,IAAI;IACnB;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 506, "column": 0}, "map": {"version":3,"sources":["file:///users/mrzasa/projects/current/frontend2.4/app/api/admin/sync-parts/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\r\nimport { getServerSession } from 'next-auth'\r\nimport { authOptions } from '@/lib/auth'\r\nimport { scanAllParts } from '@/lib/importers/part-scanner'\r\nimport { queryPrimary } from '@/lib/db/mysql-primary'\r\n\r\ntype FieldDiff = {\r\n  field: string\r\n  dbValue: any\r\n  folderValue: any\r\n  isDifferent: boolean\r\n}\r\n\r\ntype PartComparison = {\r\n  apcPN: string\r\n  folderName: string\r\n  fullPath: string\r\n  differences: FieldDiff[]\r\n  existsInDB: boolean\r\n  dbId?: number\r\n}\r\n\r\nexport async function GET() {\r\n  const session = await getServerSession(authOptions)\r\n  \r\n  if (!session) {\r\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\r\n  }\r\n\r\n  try {\r\n    // Scan filesystem\r\n    const scannedParts = await scanAllParts()\r\n    \r\n    // Get all existing parts from DB\r\n    const dbParts = await queryPrimary<any[]>(\r\n      `SELECT id, apcPN, customer, customerPN, currentRev, fullPath FROM items WHERE m_item_type_id = 1`\r\n    )\r\n    \r\n    // Create map for quick lookup\r\n    const dbPartsMap = new Map(dbParts.map(p => [p.apcPN, p]))\r\n    \r\n    // Compare each scanned part with DB\r\n    const comparisons: PartComparison[] = []\r\n    \r\n    for (const scanned of scannedParts) {\r\n      const dbPart = dbPartsMap.get(scanned.apcPN)\r\n      \r\n      if (!dbPart) {\r\n        // Part doesn't exist in DB\r\n        comparisons.push({\r\n          apcPN: scanned.apcPN,\r\n          folderName: scanned.folderName,\r\n          fullPath: scanned.fullPath,\r\n          differences: [],\r\n          existsInDB: false\r\n        })\r\n        continue\r\n      }\r\n      \r\n      // Compare fields\r\n      const differences: FieldDiff[] = [\r\n        {\r\n          field: 'customer',\r\n          dbValue: dbPart.customer,\r\n          folderValue: scanned.customer,\r\n          isDifferent: dbPart.customer !== scanned.customer\r\n        },\r\n        {\r\n          field: 'customerPN',\r\n          dbValue: dbPart.customerPN,\r\n          folderValue: scanned.customerPN,\r\n          isDifferent: dbPart.customerPN !== scanned.customerPN\r\n        },\r\n        {\r\n          field: 'currentRev',\r\n          dbValue: dbPart.currentRev,\r\n          folderValue: scanned.currentRev,\r\n          isDifferent: dbPart.currentRev !== scanned.currentRev\r\n        },\r\n        {\r\n          field: 'fullPath',\r\n          dbValue: dbPart.fullPath,\r\n          folderValue: scanned.fullPath,\r\n          isDifferent: dbPart.fullPath !== scanned.fullPath\r\n        }\r\n      ]\r\n      \r\n      const hasDifferences = differences.some(d => d.isDifferent)\r\n      \r\n      if (hasDifferences) {\r\n        comparisons.push({\r\n          apcPN: scanned.apcPN,\r\n          folderName: scanned.folderName,\r\n          fullPath: scanned.fullPath,\r\n          differences,\r\n          existsInDB: true,\r\n          dbId: dbPart.id\r\n        })\r\n      }\r\n    }\r\n    \r\n    return NextResponse.json({\r\n      total: scannedParts.length,\r\n      mismatches: comparisons.filter(c => c.existsInDB).length,\r\n      newParts: comparisons.filter(c => !c.existsInDB).length,\r\n      comparisons\r\n    })\r\n  } catch (error) {\r\n    console.error('Error comparing parts:', error)\r\n    return NextResponse.json(\r\n      { error: 'Failed to compare parts', details: String(error) },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  const session = await getServerSession(authOptions)\r\n  \r\n  if (!session) {\r\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\r\n  }\r\n\r\n  try {\r\n    const { updates } = await request.json()\r\n    \r\n    let updated = 0\r\n    const errors: string[] = []\r\n    \r\n    for (const update of updates) {\r\n      try {\r\n        await queryPrimary(\r\n          `UPDATE items SET \r\n            customer = ?,\r\n            customerPN = ?,\r\n            currentRev = ?,\r\n            fullPath = ?\r\n          WHERE id = ?`,\r\n          [\r\n            update.customer,\r\n            update.customerPN,\r\n            update.currentRev,\r\n            update.fullPath,\r\n            update.dbId\r\n          ]\r\n        )\r\n        updated++\r\n      } catch (error) {\r\n        errors.push(`${update.apcPN}: ${error}`)\r\n      }\r\n    }\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      updated,\r\n      errors\r\n    })\r\n  } catch (error) {\r\n    console.error('Error syncing parts:', error)\r\n    return NextResponse.json(\r\n      { error: 'Failed to sync parts', details: String(error) },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}"],"names":[],"mappings":"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","debugId":null}}]
}